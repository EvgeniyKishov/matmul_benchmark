#pragma once

/**
* vmoper.h - vector-matrix operations
*/

#include "math_common.h"
#include "vmdef.h"

/**
* v3deq() - (Vector 3D is EQual) проверка 3D-векторов на равенство
* @v1: первый вектор
* @v2: второй вектор
* @tol: (tolerance) допуск
* 
* Возвращает true, если векторы равны, т.е. когда их компоненты совпадают 
* с точностью @tol. В противном случае, или если tol < 0, возвращает false.
* Также false возвращается в случае, когда один из векторов равен NULL
*/
bool DLL v3deq(const struct v3d *v1, const struct v3d *v2, double tol);

/**
* v3dabs() - длина 3D-вектора
* @v: вектор
* 
* Возвращает длину вектора в виде числа типа double.
* Если v == NULL -> возвращает HUGE_VAL.
*/
double DLL v3dabs(const struct v3d *v);

/**
* v3dinfn() - (Vector 3D INFinite Norm) макс. по модулю компонента вектора
* @v: вектор
* 
* Возвращает "бесконечную" норму вектора, т.е. макс. по модулю его компоненту.
* Если v == NULL -> возвращает HUGE_VAL.
*/
double DLL v3dinfn(const struct v3d *v);

/**
* v3dnorm() - (Vector 3D NORMalize) нормирование 3D-вектора
* @v: исходный вектор
* 
* Функция вовзращает вектор, имеющий то же направление, что и {v}, только
* единичной длины. Если |v| = 0 -> возвращается нулевой вектор.
* Также нулевой вектор возвращается в случае, когда v == NULL.
*/
struct v3d DLL v3dnorm(const struct v3d *v);

/**
* v3ddot() - скалярное произведение
* @a, @b: векторы-сомножители
* 
* Возвращает скалярное произведение векторов {a} * {b}.
* Если один из аргументов равен NULL -> возвращает HUGE_VAL.
*/
double DLL v3ddot(const struct v3d *a, const struct v3d *b);

/**
* vcross() - векторное произведение 
* @a, @b: векторы-сомножители
* 
* Функция возвращает вектор, являющийся векторным произведением {a} x {b}.
* Если один из аргументов равен NULL -> возвращается нулевой вектор.
*/
struct v3d DLL vcross(const struct v3d *a, const struct v3d *b);

/**
* v3dlinc() - линейная комбинация 3-мерных векторов 
* (Vector 3D LINear Combination)
* @a, @b: слагаемые {a} и {b}
* @w, @v: коэффициенты перед {a} и {b} соответственно
* 
* Функция возвращает вектор, равный w{a} + v{b}. 
* Начало результирующего вектора помещается в точку 
* w/(v+w)*{a.base} + v/(v+w)*{b.base}.
* Один из слагаемых может быть равен NULL. В этом случае происходит 
* масштабирование оставшегося вектора.
*
* Если оба векторных аргумента равны NULL, возвращается нулевой вектор.
*/
struct v3d DLL v3dlinc(const struct v3d *a, double w, 
		       const struct v3d *b, double v);

/**
* v3dscal() - масштабирование 3D-вектора
* @a: вектор
* @w: коэфф. масштаба
* 
* Функция возвращает вектор w{a}. Если @a = NULL, возвращает нулевой вектор
*/
struct v3d DLL v3dscal(const struct v3d *a, double w);

/**
* v3dadd() - сумма 3-мерных векторов (Vector 3D ADDition)
* @a, @b: слагаемые {a} и {b}
* 
* Функция возвращает вектор {a} + {b}. 
* В случае, если оба вектора равны NULL, возвращается нулевой вектор.
*/
struct v3d DLL v3dadd(const struct v3d *a, const struct v3d *b);

/**
* v3dsum() - разность 3-мерных векторов (Vector 3D ADDition)
* @a, @b: слагаемые {a} и {b}
* 
* Функция возвращает вектор {a} - {b}. 
* В случае, если оба вектора равны NULL, возвращается нулевой вектор.
*/
struct v3d DLL v3dsub(const struct v3d *a, const struct v3d *b);

/**
* v3dmmul() - умножение 3D-матрицы на 3D-вектор
* @a: 3D-матрица
* @v: 3D-вектор
* 
* Функция осуществляет операцию [a] * {x}.
* Если a == NULL или x == NULL -> функция возвращает нулевой вектор
*/
struct v3d DLL v3dmmul(const struct m3d *a, const struct v3d *v);

/**
* veq() - (Vector is EQual) проверка N-мерных векторов на равенство
* @v1: первый вектор
* @v2: второй вектор
* @tol: (tolerance) допуск
* 
* Возвращает true, если векторы равны, т.е. когда их компоненты совпадают с 
* точностью @tol. В противном случае, или когда векторы имеют разную
* размерность, или когда tol < 0, возвращает false. 
* Также false возвращается в случае, когда один из аргументов равен NULL.
*/
bool DLL veq(const struct vec *v1, const struct vec *v2, double tol);

/**
* vabs() - модуль (эвклидова норма) вектора
* @a: вектор
* 
* Возвращает длину вектора. Если a == NULL -> возвращает HUGE_VAL.
*/
double DLL vabs(const struct vec *a);

/**
* vinfn() - (Vector INFinite Norm) макс. по модулю компонента N-вектора
* @a: вектор
* 
* Возвращает "бесконечную" норму вектора, т.е. макс. по модулю его компоненту.
* Если a == NULL -> возвращает HUGE_VAL
*/
double DLL vinfn(const struct vec *a);

/**
* vlincom() - линейная комбинация n-мерных векторов (Vector LINear COMbination)
* @c: результирующий вектор
* @a, @b: слагаемые {a} и {b}
* @w, @v: коэффициенты перед {a} и {b} соответственно
* 
* Функция выполняет операцию {c} = w{a} + v{b}. 
* Один из слагаемых может быть равен NULL. В этом случае происходит 
* масштабирование оставшегося вектора.
* В случае успеха возвращает 0. В случае, если векторы имеют разный размер, 
* возвращается -1. Если оба аргумента равны NULL, возвращается -2.
*/
int DLL vlincom(struct vec *c, const struct vec *a, double w, 
			       const struct vec *b, double v);

/**
* vadd() - сумма n-мерных векторов (Vector ADDition)
* @c: результирующий вектор
* @a, @b: слагаемые {a} и {b}
* 
* Функция выполняет операцию {c} = {a} + {b}. В случае успеха возвращает 0.
* В случае, если векторы имеют разный размер, возвращается -1.
*/
int DLL vadd(struct vec *c, const struct vec *a, const struct vec *b);

/**
* vsub() - разность n-мерных векторов (Vector SUBtraction)
* @c: результирующий вектор
* @a, @b: векторы {a} и {b}
* 
* Функция выполняет операцию {c} = {a} - {b}. В случае успеха возвращает 0.
* В случае, если векторы имеют разный размер, возвращается -1.
*/
int DLL vsub(struct vec *c, const struct vec *a, const struct vec *b);

/**
* vscal() - масштабирование n-мерного вектора (Vector SCALe)
* @as: результирующий вектор
* @a: исходный вектор
* @w: коэффициент масштаба
* 
* Функция выполняет операцию {as} = w*{a}. В случае успеха возвращает 0.
* В случае, если векторы имеют разный размер, возвращается -1.
*/
int DLL vscal(struct vec *as, const struct vec *a, double w);

/**
* vmmul() - умножение матрицы на вектор
* @b: результирующий вектор
* @a: матрица
* @x: вектор
* 
* Если какой-либо из аргументов == NULL -> возвращается -1. Если аргументы
* не согласованы по размерности -> возвращается -2. В случае успеха
* возвращается 0.
*/
int DLL vmmul(struct vec *b, const struct matr *a, const struct vec *x);

/**
* matmul() - умножение матриц
* @c: результат
* @a: первый сомножитель
* @b: второй сомножитель
* 
* Функция осуществляет матричное умножение:
* [c] = [a] * [b]
* Если один из аргументов равен NULL -> возвращает -2.
* Если размерности матриц не согласованы - возвращает -1.
* В случае успеха возвращает 0.
*/
int DLL matmul(struct matr *c, const struct matr *a, const struct matr *b);

/**
* mtrans() - транспонирование матрицы
* @at: транспонированная матрица
* @a: исходная матрица
* 
* Функция осуществляет операцию [at] = trans([a])
* Если один из аргументов равен NULL -> возвращает -2.
* В случае успеха возвращает 0.
*/
int DLL mtrans(struct matr *at, const struct matr *a);

/**
* mmdbl() - двойное умножение матриц (Matrix Multiplication DouBLe)
* @k: результирующая матрица
* @c: _квадратная_ матрица, подлежащая "двустороннему" умножению
* @b: "окаямляющая" матрица
* 
* Функция осуществляет операцию двукратного умножения матриц:
* [k] = trans([b]) * [c] * [b]. 
* Если [c] - симметричная, то [k] тоже получается симметричной.
* Если один из аргументов равен NULL -> возвращает -2.
* В случае успеха возвращает 0
*/
int DLL mmdbl(struct matr *k, const struct matr *c, const struct matr *b);

/**
* mmdbl_u() - двойное несимметричное умножение матриц 
*	     (Matrix Multiplication DouBLe Unsymmetric)
* @k: результирующая матрица
* @g: первый сомножитель
* @c: _квадратная_ матрица, подлежащая "двустороннему" умножению
* @b: второс сомножитель
* 
* Функция осуществляет операцию двукратного умножения матриц:
* [k] = trans([g]) * [c] * [b].
* Если один из аргументов равен NULL -> возвращает -2.
* В случае успеха возвращает 0.
*/
int DLL mmdbl_u(struct matr *k, const struct matr *g, const struct matr *b, 
	        const struct matr *c);

/**
* mlincom() - линейная комбинация матриц (Matrix LINear COMbination)
* @c: результирующая матрица
* @a, @b: слагаемые [a] и [b]
* @w, @v: коэффициенты перед [a] и [b] соответственно
* 
* Функция выполняет операцию [c] = w[a] + v[b]. 
* Один из слагаемых может быть равен NULL. В этом случае происходит 
* масштабирование оставшейся матрицы.
* В случае успеха возвращает 0. В случае, если матрицы не согласованы 
* по размеру, возвращается -1. Если оба аргумента равны NULL, 
* возвращается -2.
*/
int DLL mlincom(struct matr *c, const struct matr *a, double w, 
			        const struct matr *b, double v);

/**
* madd() - сумма матриц (Matrix ADDition)
* @c: результирующая матрица
* @a, @b: слагаемые [a] и [b]
* 
* Функция выполняет операцию [c] = [a] + [b]. В случае успеха возвращает 0.
* В случае если, матрицы не согласованы по размеру, возвращается -1.
*/
int DLL madd(struct matr *c, const struct matr *a, const struct matr *b);

/**
* msub() - разнось матриц (Matrix SUBtraction)
* @c: результирующая матрица
* @a, @b: матрицы [a] и [b]
* 
* Функция выполняет операцию [c] = [a] - [b]. В случае успеха возвращает 0.
* В случае если, матрицы не согласованы по размеру, возвращается -1.
*/
int DLL msub(struct matr *c, const struct matr *a, const struct matr *b);

/**
* mscal() - масштабирование матрицы (Matrix SCALe)
* @as: результирующая матрицы
* @a: исходная матрицы
* @w: коэффициент масштаба
* 
* Функция выполняет операцию [as] = w*[a]. В случае успеха возвращает 0.
* В случае, если векторы имеют разный размер, возвращается -1.
*/
int DLL mscal(struct matr *as, const struct matr *a, double w);